{"componentChunkName":"component---src-templates-blog-post-js","path":"/go-program-pattern-slice-interface-time","result":{"data":{"site":{"siteMetadata":{"title":"Panda8z`s Blog"}},"markdownRemark":{"id":"5b4bd152-7343-5b1f-81e6-f3ce909952b4","excerpt":"img 在本篇文章中，我会对Go语言编程模式的一些基本技术和要点，这样可以让你更容易掌握Go语言编程。其中，主要包括，数组切片的一些小坑，还有接口编程，以及时间和程序运行性能相关的话题。 Slice 首先，我们先来讨论一下Slice，中文翻译叫“切片”，这个东西在Go…","html":"<p><img src=\"https://tva1.sinaimg.cn/large/0081Kckwgy1gm57390hfjj308c04pt8o.jpg\" alt=\"img\"></p>\n<p>在本篇文章中，我会对Go语言编程模式的一些基本技术和要点，这样可以让你更容易掌握Go语言编程。其中，主要包括，数组切片的一些小坑，还有接口编程，以及时间和程序运行性能相关的话题。</p>\n<h2>Slice</h2>\n<p>首先，我们先来讨论一下Slice，中文翻译叫“切片”，这个东西在Go语言中不是数组，而是一个结构体，其定义如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">type</span> slice <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">{</span>\n  array unsafe<span class=\"token punctuation\">.</span>Pointer <span class=\"token comment\">//指向存放数据的数组指针</span>\n  <span class=\"token builtin\">len</span>   <span class=\"token builtin\">int</span>            <span class=\"token comment\">//长度有多大</span>\n  <span class=\"token builtin\">cap</span>   <span class=\"token builtin\">int</span>            <span class=\"token comment\">//容量有多大</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>用图示来看，一个空的slice的表现如下：</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/0081Kckwgy1gm5738j9rpj308c05a0sm.jpg\" alt=\"img\"></p>\n<p>熟悉C/C++的同学一定会知道，在结构体里用数组指针的问题——数据会发生共享！下面我们来看一下slice的一些操作</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\">foo <span class=\"token operator\">=</span> <span class=\"token function\">make</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">)</span>\nfoo<span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">42</span>\nfoo<span class=\"token punctuation\">[</span><span class=\"token number\">4</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">100</span>\n\nbar  <span class=\"token operator\">:=</span> foo<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">:</span><span class=\"token number\">4</span><span class=\"token punctuation\">]</span>\nbar<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">99</span></code></pre></div>\n<p>对于上面这段代码。</p>\n<ul>\n<li>首先先创建一个foo的slice，其中的长度和容量都是5</li>\n<li>然后开始对foo所指向的数组中的索引为3和4的元素进行赋值</li>\n<li>然后，对foo做切片后赋值给bar，再修改bar[1]</li>\n</ul>\n<img src=\"https://coolshell.cn/wp-content/uploads/2020/12/slice2.png\" alt=\"img\" style=\"zoom:50%;\">\n<p>通过上图我们可以看到，因为foo和bar的内存是共享的，所以，foo和bar的对数组内容的修改都会影响到对方。</p>\n<p>接下来，我们再来看一个数据操作 <code class=\"language-text\">append()</code> 的示例</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\">a <span class=\"token operator\">:=</span> <span class=\"token function\">make</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> <span class=\"token number\">32</span><span class=\"token punctuation\">)</span>\nb <span class=\"token operator\">:=</span> a<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">:</span><span class=\"token number\">16</span><span class=\"token punctuation\">]</span>\n\na <span class=\"token operator\">=</span> <span class=\"token function\">append</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\na<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">42</span></code></pre></div>\n<p>上面这段代码中，把 <code class=\"language-text\">a[1:16]</code> 的切片赋给到了 <code class=\"language-text\">b</code> ，此时，<code class=\"language-text\">a</code> 和 <code class=\"language-text\">b</code> 的内存空间是共享的，然后，对 <code class=\"language-text\">a</code>做了一个 <code class=\"language-text\">append()</code>的操作，这个操作会让 <code class=\"language-text\">a</code> 重新分享内存，导致 <code class=\"language-text\">a</code> 和 <code class=\"language-text\">b</code> 不再共享，如下图所示：</p>\n<img src=\"https://coolshell.cn/wp-content/uploads/2020/12/slice3.png\" alt=\"img\" style=\"zoom:50%;\">\n<p>从上图我们可以看以看到 <code class=\"language-text\">append()</code>操作让 <code class=\"language-text\">a</code> 的容量变成了64，而长度是33。这里，需要重点注意一下——<strong><code class=\"language-text\">append()</code>这个函数在 <code class=\"language-text\">cap</code> 不够用的时候就会重新分配内存以扩大容量，而如果够用的时候不不会重新分享内存！</strong></p>\n<p>我们再看来看一个例子：</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>  \n  path <span class=\"token operator\">:=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token function\">byte</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"AAAA/BBBBBBBBB\"</span><span class=\"token punctuation\">)</span>\n  sepIndex <span class=\"token operator\">:=</span> bytes<span class=\"token punctuation\">.</span><span class=\"token function\">IndexByte</span><span class=\"token punctuation\">(</span>path<span class=\"token punctuation\">,</span>'<span class=\"token operator\">/</span>’<span class=\"token punctuation\">)</span>\n  dir1 <span class=\"token operator\">:=</span> path<span class=\"token punctuation\">[</span><span class=\"token punctuation\">:</span>sepIndex<span class=\"token punctuation\">]</span>\n  dir2 <span class=\"token operator\">:=</span> path<span class=\"token punctuation\">[</span>sepIndex<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">:</span><span class=\"token punctuation\">]</span>\n  fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"dir1 =>\"</span><span class=\"token punctuation\">,</span><span class=\"token function\">string</span><span class=\"token punctuation\">(</span>dir1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">//prints: dir1 => AAAA</span>\n  fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"dir2 =>\"</span><span class=\"token punctuation\">,</span><span class=\"token function\">string</span><span class=\"token punctuation\">(</span>dir2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">//prints: dir2 => BBBBBBBBB</span>\n  dir1 <span class=\"token operator\">=</span> <span class=\"token function\">append</span><span class=\"token punctuation\">(</span>dir1<span class=\"token punctuation\">,</span><span class=\"token string\">\"suffix\"</span><span class=\"token operator\">...</span><span class=\"token punctuation\">)</span> \n  fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"dir1 =>\"</span><span class=\"token punctuation\">,</span><span class=\"token function\">string</span><span class=\"token punctuation\">(</span>dir1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">//prints: dir1 => AAAAsuffix</span>\n  fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"dir2 =>\"</span><span class=\"token punctuation\">,</span><span class=\"token function\">string</span><span class=\"token punctuation\">(</span>dir2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">//prints: dir2 => uffixBBBB </span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>上面这个例子中，<code class=\"language-text\">dir1</code> 和 <code class=\"language-text\">dir2</code> 共享内存，虽然 <code class=\"language-text\">dir1</code> 有一个 <code class=\"language-text\">append()</code> 操作，但是因为 cap 足够，于是数据扩展到了<code class=\"language-text\">dir2</code> 的空间。下面是相关的图示（注意上图中 <code class=\"language-text\">dir1</code> 和 <code class=\"language-text\">dir2</code> 结构体中的 <code class=\"language-text\">cap</code> 和 <code class=\"language-text\">len</code> 的变化）</p>\n<img src=\"https://coolshell.cn/wp-content/uploads/2020/12/slice4-1024x740.png\" alt=\"img\" style=\"zoom:50%;\">\n<p>如果要解决这个问题，我们只需要修改一行代码。</p>\n<p>dir1 := path[:sepIndex]</p>\n<p>修改为</p>\n<p>dir1 := path[:sepIndex:sepIndex]</p>\n<p>新的代码使用了 Full Slice Expression，其最后一个参数叫“Limited Capacity”，于是，后续的 <code class=\"language-text\">append()</code> 操作将会导致重新分配内存。</p>\n<h2>深度比较</h2>\n<p>当我们复杂一个对象时，这个对象可以是内建数据类型，数组，结构体，map……我们在复制结构体的时候，当我们需要比较两个结构体中的数据是否相同时，我们需要使用深度比较，而不是只是简单地做浅度比较。这里需要使用到反射 <code class=\"language-text\">reflect.DeepEqual()</code> ，下面是几个示例</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">(</span>  \n  <span class=\"token string\">\"fmt\"</span>\n  <span class=\"token string\">\"reflect\"</span>\n<span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>  \n   v1 <span class=\"token operator\">:=</span> data<span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n   v2 <span class=\"token operator\">:=</span> data<span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n   fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"v1 == v2:\"</span><span class=\"token punctuation\">,</span>reflect<span class=\"token punctuation\">.</span><span class=\"token function\">DeepEqual</span><span class=\"token punctuation\">(</span>v1<span class=\"token punctuation\">,</span>v2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> \n   <span class=\"token comment\">//prints: v1 == v2: true</span>\n   m1 <span class=\"token operator\">:=</span> <span class=\"token keyword\">map</span><span class=\"token punctuation\">[</span><span class=\"token builtin\">string</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">string</span><span class=\"token punctuation\">{</span><span class=\"token string\">\"one\"</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"a\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"two\"</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"b\"</span><span class=\"token punctuation\">}</span>\n   m2 <span class=\"token operator\">:=</span> <span class=\"token keyword\">map</span><span class=\"token punctuation\">[</span><span class=\"token builtin\">string</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">string</span><span class=\"token punctuation\">{</span><span class=\"token string\">\"two\"</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"b\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"one\"</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"a\"</span><span class=\"token punctuation\">}</span>\n   fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"m1 == m2:\"</span><span class=\"token punctuation\">,</span>reflect<span class=\"token punctuation\">.</span><span class=\"token function\">DeepEqual</span><span class=\"token punctuation\">(</span>m1<span class=\"token punctuation\">,</span> m2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> \n   <span class=\"token comment\">//prints: m1 == m2: true</span>\n   s1 <span class=\"token operator\">:=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">{</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">}</span>\n   s2 <span class=\"token operator\">:=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">{</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">}</span>\n   fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"s1 == s2:\"</span><span class=\"token punctuation\">,</span>reflect<span class=\"token punctuation\">.</span><span class=\"token function\">DeepEqual</span><span class=\"token punctuation\">(</span>s1<span class=\"token punctuation\">,</span> s2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> \n   <span class=\"token comment\">//prints: s1 == s2: true</span>\n\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2>接口编程</h2>\n<p>下面，我们来看段代码，其中是两个方法，它们都是要输出一个结构体，其中一个使用一个函数，另一个使用一个“成员函数”。</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">PrintPerson</span><span class=\"token punctuation\">(</span>p <span class=\"token operator\">*</span>Person<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Name=%s, Sexual=%s, Age=%d\\n\"</span><span class=\"token punctuation\">,</span> p<span class=\"token punctuation\">.</span>Name<span class=\"token punctuation\">,</span> p<span class=\"token punctuation\">.</span>Sexual<span class=\"token punctuation\">,</span> p<span class=\"token punctuation\">.</span>Age<span class=\"token punctuation\">)</span>\n\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>p <span class=\"token operator\">*</span>Person<span class=\"token punctuation\">)</span> <span class=\"token function\">Print</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Name=%s, Sexual=%s, Age=%d\\n\"</span><span class=\"token punctuation\">,</span> p<span class=\"token punctuation\">.</span>Name<span class=\"token punctuation\">,</span> p<span class=\"token punctuation\">.</span>Sexual<span class=\"token punctuation\">,</span> p<span class=\"token punctuation\">.</span>Age<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">var</span> p <span class=\"token operator\">=</span> Person<span class=\"token punctuation\">{</span>\n      Name<span class=\"token punctuation\">:</span> <span class=\"token string\">\"Hao Chen\"</span><span class=\"token punctuation\">,</span>\n      Sexual<span class=\"token punctuation\">:</span> <span class=\"token string\">\"Male\"</span><span class=\"token punctuation\">,</span>\n      Age<span class=\"token punctuation\">:</span> <span class=\"token number\">44</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token function\">PrintPerson</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>p<span class=\"token punctuation\">)</span>\n  p<span class=\"token punctuation\">.</span><span class=\"token function\">Print</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>你更喜欢哪种方式呢？在 Go 语言中，使用“成员函数”的方式叫“Receiver”，这种方式是一种封装，因为 <code class=\"language-text\">PrintPerson()</code>本来就是和 <code class=\"language-text\">Person</code>强耦合的，所以，理应放在一起。更重要的是，这种方式可以进行接口编程，对于接口编程来说，也就是一种抽象，主要是用在“多态”，这个技术，在《<a href=\"https://coolshell.cn/articles/8460.html#%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%A4%9A%E6%80%81\">Go语言简介（上）：接口与多态</a>》中已经讲过。在这里，我想讲另一个Go语言接口的编程模式。</p>\n<p>首先，我们来看一下，有下面这段代码：</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">type</span> Country <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">{</span>\n  Name <span class=\"token builtin\">string</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">type</span> City <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">{</span>\n  Name <span class=\"token builtin\">string</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">type</span> Printable <span class=\"token keyword\">interface</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">PrintStr</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> \n<span class=\"token punctuation\">}</span>  \n\n<span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>c Country<span class=\"token punctuation\">)</span> <span class=\"token function\">PrintStr</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">.</span>Name<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>  \n\n<span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>c City<span class=\"token punctuation\">)</span> <span class=\"token function\">PrintStr</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">.</span>Name<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\nc1 <span class=\"token operator\">:=</span> Country <span class=\"token punctuation\">{</span><span class=\"token string\">\"China\"</span><span class=\"token punctuation\">}</span>\nc2 <span class=\"token operator\">:=</span> City <span class=\"token punctuation\">{</span><span class=\"token string\">\"Beijing\"</span><span class=\"token punctuation\">}</span>  \nc1<span class=\"token punctuation\">.</span><span class=\"token function\">PrintStr</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>其中，我们可以看到，其使用了一个 <code class=\"language-text\">Printable</code> 的接口，而 <code class=\"language-text\">Country</code> 和 <code class=\"language-text\">City</code> 都实现了接口方法 <code class=\"language-text\">PrintStr()</code> 而把自己输出。然而，这些代码都是一样的。能不能省掉呢？</p>\n<p>我们可以使用“结构体嵌入”的方式来完成这个事，如下的代码所示，</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">type</span> WithName <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">{</span>\n  Name <span class=\"token builtin\">string</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">type</span> Country <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">{</span>\n  WithName\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">type</span> City <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">{</span>\n  WithName\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">type</span> Printable <span class=\"token keyword\">interface</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">PrintStr</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> \n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>w WithName<span class=\"token punctuation\">)</span> <span class=\"token function\">PrintStr</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span>w<span class=\"token punctuation\">.</span>Name<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\nc1 <span class=\"token operator\">:=</span> Country <span class=\"token punctuation\">{</span>WithName<span class=\"token punctuation\">{</span> <span class=\"token string\">\"China\"</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">}</span>\nc2 <span class=\"token operator\">:=</span> City <span class=\"token punctuation\">{</span> WithName<span class=\"token punctuation\">{</span><span class=\"token string\">\"Beijing\"</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">}</span>  \n\nc1<span class=\"token punctuation\">.</span><span class=\"token function\">PrintStr</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\nc2<span class=\"token punctuation\">.</span><span class=\"token function\">PrintStr</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>引入一个叫 <code class=\"language-text\">WithName</code>的结构体，然而，所带来的问题就是，在初始化的时候，变得有点乱。那么，我们有没有更好的方法？下面是另外一个解。</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">type</span> Country <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">{</span>\n  Name <span class=\"token builtin\">string</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">type</span> City <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">{</span>\n  Name <span class=\"token builtin\">string</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">type</span> Stringable <span class=\"token keyword\">interface</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">ToString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token builtin\">string</span>\n<span class=\"token punctuation\">}</span>  \n\n<span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>c Country<span class=\"token punctuation\">)</span> <span class=\"token function\">ToString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token builtin\">string</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token string\">\"Country = \"</span> <span class=\"token operator\">+</span> c<span class=\"token punctuation\">.</span>Name\n\n<span class=\"token punctuation\">}</span>  \n\n<span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>c City<span class=\"token punctuation\">)</span> <span class=\"token function\">ToString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token string\">\"City = \"</span> <span class=\"token operator\">+</span> c<span class=\"token punctuation\">.</span>Name\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token function\">PrintStr</span><span class=\"token punctuation\">(</span>p Stringable<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">.</span><span class=\"token function\">ToString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\nd1 <span class=\"token operator\">:=</span> Country <span class=\"token punctuation\">{</span><span class=\"token string\">\"USA\"</span><span class=\"token punctuation\">}</span>\nd2 <span class=\"token operator\">:=</span> City<span class=\"token punctuation\">{</span><span class=\"token string\">\"Los Angeles\"</span><span class=\"token punctuation\">}</span>  \n\n<span class=\"token function\">PrintStr</span><span class=\"token punctuation\">(</span>d1<span class=\"token punctuation\">)</span>\n<span class=\"token function\">PrintStr</span><span class=\"token punctuation\">(</span>d2<span class=\"token punctuation\">)</span></code></pre></div>\n<p>上面这段代码，我们可以看到——<strong>我们使用了一个叫<code class=\"language-text\">Stringable</code> 的接口，我们用这个接口把“业务类型” <code class=\"language-text\">Country</code> 和 <code class=\"language-text\">City</code> 和“控制逻辑” <code class=\"language-text\">Print()</code> 给解耦了。</strong>于是，只要实现了<code class=\"language-text\">Stringable</code> 接口，都可以传给 <code class=\"language-text\">PrintStr()</code> 来使用。</p>\n<p>这种编程模式在Go 的标准库有很多的示例，最著名的就是 <code class=\"language-text\">io.Read</code> 和 <code class=\"language-text\">ioutil.ReadAll</code> 的玩法，其中 <code class=\"language-text\">io.Read</code> 是一个接口，你需要实现他的一个 <code class=\"language-text\">Read(p []byte) (n int, err error)</code> 接口方法，只要满足这个规模，就可以被 <code class=\"language-text\">ioutil.ReadAll</code>这个方法所使用。<strong>这就是面向对象编程方法的黄金法则——“Program to an interface not an implementation”</strong></p>\n<h2>接口完整性检查</h2>\n<p>另外，我们可以看到，Go语言的编程器并没有严格检查一个对象是否实现了某接口所有的接口方法，如下面这个示例：</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">type</span> Shape <span class=\"token keyword\">interface</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">Sides</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token builtin\">int</span>\n  <span class=\"token function\">Area</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token builtin\">int</span>\n<span class=\"token punctuation\">}</span>  \n\n<span class=\"token keyword\">type</span> Square <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token builtin\">len</span> <span class=\"token builtin\">int</span>\n<span class=\"token punctuation\">}</span>   \n\n<span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>s<span class=\"token operator\">*</span> Square<span class=\"token punctuation\">)</span> <span class=\"token function\">Sides</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token builtin\">int</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token number\">4</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  s <span class=\"token operator\">:=</span> Square<span class=\"token punctuation\">{</span><span class=\"token builtin\">len</span><span class=\"token punctuation\">:</span> <span class=\"token number\">5</span><span class=\"token punctuation\">}</span>\n  fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%d\\n\"</span><span class=\"token punctuation\">,</span>s<span class=\"token punctuation\">.</span><span class=\"token function\">Sides</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>我们可以看到 <code class=\"language-text\">Square</code> 并没有实现 <code class=\"language-text\">Shape</code> 接口的所有方法，程序虽然可以跑通，但是这样编程的方式并不严谨，如果我们需要强制实现接口的所有方法，那么我们应该怎么办呢？</p>\n<p>在Go语言编程圈里有一个比较标准的作法：</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">var</span> <span class=\"token boolean\">_</span> Shape <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>Square<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">nil</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>声明一个 <code class=\"language-text\">_</code> 变量（没人用），其会把一个 <code class=\"language-text\">nil</code> 的空指针，从 <code class=\"language-text\">Square</code> 转成 <code class=\"language-text\">Shape</code>，这样，如果没有实现完相关的接口方法，编译器就会报错：</p>\n<blockquote>\n<p>cannot use (*Square)(nil) (type *Square) as type Shape in assignment: *Square does not implement Shape (missing Area method)</p>\n</blockquote>\n<p>这样就做到了个强验证的方法。</p>\n<h2>时间</h2>\n<p>对于时间来说，这应该是编程中比较复杂的问题了，相信我，时间是一种非常复杂的事（比如《<a href=\"https://coolshell.cn/articles/5075.html\">你确信你了解时间吗？</a>》、《<a href=\"https://coolshell.cn/articles/7804.html\">关于闰秒</a>》等文章）。而且，时间有时区、格式、精度等等问题，其复杂度不是一般人能处理的。所以，一定要重用已有的时间处理，而不是自己干。</p>\n<p>在 Go 语言中，你一定要使用 <code class=\"language-text\">time.Time</code> 和 <code class=\"language-text\">time.Duration</code> 两个类型：</p>\n<ul>\n<li>在命令行上，<code class=\"language-text\">flag</code> 通过 <code class=\"language-text\">time.ParseDuration</code> 支持了 <code class=\"language-text\">time.Duration</code></li>\n<li>JSon 中的 <code class=\"language-text\">encoding/json</code> 中也可以把<code class=\"language-text\">time.Time</code> 编码成 <a href=\"https://tools.ietf.org/html/rfc3339\">RFC 3339</a> 的格式</li>\n<li>数据库使用的 <code class=\"language-text\">database/sql</code> 也支持把 <code class=\"language-text\">DATATIME</code> 或 <code class=\"language-text\">TIMESTAMP</code> 类型转成 <code class=\"language-text\">time.Time</code></li>\n<li>YAML你可以使用 <code class=\"language-text\">gopkg.in/yaml.v2</code> 也支持 <code class=\"language-text\">time.Time</code> 、<code class=\"language-text\">time.Duration</code> 和 <a href=\"https://tools.ietf.org/html/rfc3339\">RFC 3339</a> 格式</li>\n</ul>\n<p>如果你要和第三方交互，实在没有办法，也请使用 <a href=\"https://tools.ietf.org/html/rfc3339\">RFC 3339</a> 的格式。</p>\n<p>最后，如果你要做全球化跨时区的应用，你一定要把所有服务器和时间全部使用UTC时间。</p>\n<h2>性能提示</h2>\n<p>Go 语言是一个高性能的语言，但并不是说这样我们就不用关心性能了，我们还是需要关心的。下面是一个在编程方面和性能相关的提示。</p>\n<ul>\n<li>如果需要把数字转字符串，使用 <code class=\"language-text\">strconv.Itoa()</code> 会比 <code class=\"language-text\">fmt.Sprintf()</code> 要快一倍左右</li>\n<li>尽可能地避免把<code class=\"language-text\">String</code>转成<code class=\"language-text\">[]Byte</code> 。这个转换会导致性能下降。</li>\n<li>如果在for-loop里对某个slice 使用 <code class=\"language-text\">append()</code>请先把 slice的容量很扩充到位，这样可以避免内存重新分享以及系统自动按2的N次方幂进行扩展但又用不到，从而浪费内存。</li>\n<li>使用<code class=\"language-text\">StringBuffer</code> 或是<code class=\"language-text\">StringBuild</code> 来拼接字符串，会比使用 <code class=\"language-text\">+</code> 或 <code class=\"language-text\">+=</code> 性能高三到四个数量级。</li>\n<li>尽可能的使用并发的 go routine，然后使用 <code class=\"language-text\">sync.WaitGroup</code> 来同步分片操作</li>\n<li>避免在热代码中进行内存分配，这样会导致gc很忙。尽可能的使用 <code class=\"language-text\">sync.Pool</code> 来重用对象。</li>\n<li>使用 lock-free的操作，避免使用 mutex，尽可能使用 <code class=\"language-text\">sync/Atomic</code>包。 （关于无锁编程的相关话题，可参看《<a href=\"https://coolshell.cn/articles/8239.html\">无锁队列实现</a>》或《<a href=\"https://coolshell.cn/articles/9703.html\">无锁Hashmap实现</a>》）</li>\n<li>使用 I/O缓冲，I/O是个非常非常慢的操作，使用 <code class=\"language-text\">bufio.NewWrite()</code> 和 <code class=\"language-text\">bufio.NewReader()</code> 可以带来更高的性能。</li>\n<li>对于在for-loop里的固定的正则表达式，一定要使用 <code class=\"language-text\">regexp.Compile()</code> 编译正则表达式。性能会得升两个数量级。</li>\n<li>如果你需要更高性能的协议，你要考虑使用 <a href=\"https://github.com/golang/protobuf\">protobuf</a> 或 <a href=\"https://github.com/tinylib/msgp\">msgp</a> 而不是JSON，因为JSON的序列化和反序列化里使用了反射。</li>\n<li>你在使用map的时候，使用整型的key会比字符串的要快，因为整型比较比字符串比较要快。</li>\n</ul>\n<h2>参考文档</h2>\n<p>还有很多不错的技巧，下面的这些参考文档可以让你写出更好的Go的代码，必读！</p>\n<ul>\n<li><strong>Effective</strong> <strong>Go</strong><a href=\"https://golang.org/doc/effective_go.html\">https://golang.org/doc/effective_go.html</a></li>\n<li><strong>Uber</strong> <strong>Go</strong> <strong>Style</strong><a href=\"https://github.com/uber-go/guide/blob/master/style.md\">https://github.com/uber-go/guide/blob/master/style.md</a></li>\n<li><strong>50 Shades of Go: Traps, Gotchas, and Common Mistakes for New Golang Devs</strong><a href=\"http://devs.cloudimmunity.com/gotchas-and-common-mistakes-in-go-golang/\">http://devs.cloudimmunity.com/gotchas-and-common-mistakes-in-go-golang/</a></li>\n<li><strong>Go</strong> <strong>Advice</strong><a href=\"https://github.com/cristaloleg/go-advice\">https://github.com/cristaloleg/go-advice</a></li>\n<li><strong>Practical Go Benchmarks</strong><a href=\"https://www.instana.com/blog/practical-golang-benchmarks/\">https://www.instana.com/blog/practical-golang-benchmarks/</a></li>\n<li><strong>Benchmarks of Go serialization methods</strong><a href=\"https://github.com/alecthomas/go_serialization_benchmarks\">https://github.com/alecthomas/go_serialization_benchmarks</a></li>\n<li><strong>Debugging</strong> <strong>performance</strong> <strong>issues</strong> <strong>in</strong> <strong>Go</strong> <strong>programs</strong><a href=\"https://github.com/golang/go/wiki/Performance\">https://github.com/golang/go/wiki/Performance</a></li>\n<li><strong>Go</strong> <strong>code</strong> <strong>refactoring:</strong> <strong>the</strong> <strong>23x</strong> <strong>performance</strong> <strong>hunt</strong><a href=\"https://medium.com/@val_deleplace/go-code-refactoring-the-23x-performance-hunt-156746b522f7\">https://medium.com/@val_deleplace/go-code-refactoring-the-23x-performance-hunt-156746b522f7</a></li>\n</ul>\n<p>（全文完）</p>\n<p>转载：文章作者和出处 <a href=\"https://coolshell.cn/\">酷 壳 – CoolShell</a></p>\n<p><img src=\"https://coolshell.cn/wp-content/uploads/2020/03/coolshell.weixin.jpg\" alt=\"img\" style=\"zoom:33%;\"> <img src=\"https://coolshell.cn/wp-content/uploads/2020/03/coolshell.mini_.jpg\" alt=\"img\" style=\"zoom:33%;\">\n关注CoolShell微信公众账号和微信小程序</p>","frontmatter":{"title":"GO编程模式01：切片，接口，时间和性能","date":"2021-01-24T11:01:00.000Z","description":null}},"previous":null,"next":{"fields":{"slug":"/Go编程模式-转载自酷壳/GO 编程模式：错误处理/"},"frontmatter":{"title":"GO 编程模式02：错误处理","slug":"go-program-pattern-handle-errors"}}},"pageContext":{"id":"5b4bd152-7343-5b1f-81e6-f3ce909952b4","previousPostId":null,"nextPostId":"1dd5ad20-3a11-5306-bede-b04575975555"}},"staticQueryHashes":["2841359383","394414991"]}